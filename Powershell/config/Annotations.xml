<?xml version="1.0" encoding="utf-8"?>
<Summaries>
  <System>
    <Enum>
      <Methods>
        <AnnotationType>Predefined</AnnotationType>
        <Annotation>BasicScalarSystemCall</Annotation>
      </Methods>
    </Enum>
    <Environment>
      <Methods>
        <AnnotationType>Predefined</AnnotationType>
        <Annotation>BasicScalarSystemCall</Annotation>
      </Methods>
    </Environment>
    <Console>
      <Methods>
        <AnnotationType>Predefined</AnnotationType>
        <Annotation>BasicScalarSystemCall</Annotation>
      </Methods>
      <Properties>
        <AnnotationType>Predefined</AnnotationType>
        <Annotation>BasicScalarSystemProperty</Annotation>
      </Properties>
    </Console>
    <Object>
      <Methods>
        <ctor>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{}.{RV.?}.{}</Annotation>
        </ctor>
        <ToString>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R}.{}.{}</Annotation>
        </ToString>
        <ReferenceEquals>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R;P}.{}.{}</Annotation>
        </ReferenceEquals>
        <GetType>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{R}.{RV.?}.{}</Annotation>
        </GetType>
		<Equals>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R}.{}.{}</Annotation>
        </Equals>
		<GetHashCode>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R}.{}.{}</Annotation>
        </GetHashCode>
      </Methods>
    </Object>
    <String>
      <Methods>
        <AnnotationType>Predefined</AnnotationType>
        <Annotation>BasicScalarSystemCall</Annotation>
        <IsNullOrEmpty>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R;P}.{}.{}</Annotation>
        </IsNullOrEmpty>
      </Methods>
    </String>
    <Int32>
      <Methods>
        <AnnotationType>Predefined</AnnotationType>
        <Annotation>BasicScalarSystemCall</Annotation>
      </Methods>
    </Int32>
    <DateTime>
      <Properties>
        <Now>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{}.{}.{}</Annotation>
        </Now>
      </Properties>
      <Methods>
        <Subtract>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{P.?}.{}.{}</Annotation>
        </Subtract>
        <ctor>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{P}.{}.{}</Annotation>
        </ctor>
        <ParseExact>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{P}.{RV.?}.{}</Annotation>
        </ParseExact>
        <op_Subtraction>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{P;P.?}.{RV.?}.{}</Annotation>
        </op_Subtraction>
      </Methods>
    </DateTime>
    <Guid>
      <Methods>
        <ctor>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{}.{RV.?}.{}</Annotation>
        </ctor>
        <NewGuid>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{P}.{RV.?}.{}</Annotation>
        </NewGuid>
        <GetHashCode>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R.?}.{}.{}</Annotation>
        </GetHashCode>
        <ToString>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R;R.?;P}.{}.{}</Annotation>
        </ToString>
      </Methods>
    </Guid>
    <Math>
      <Methods>
        <AnnotationType>Predefined</AnnotationType>
        <Annotation>BasicScalarSystemCall</Annotation>
      </Methods>
    </Math>
    <Exception>
      <Methods>
        <ctor>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{Many}.{P}.{RV.?;RO.?}.{[RV;RO, RO, ?]}</Annotation>
        </ctor>
      </Methods>
    </Exception>
    <Array>
      <Methods>
        <ctor>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{P}.{RV.?}.{}</Annotation>
        </ctor>
      </Methods>
      <Properties>
        <AnnotationType>Custom</AnnotationType>
        <Annotation>Null.{}.{R.?}.{}.{}</Annotation>
      </Properties>
    </Array>
    <Type>
      <Methods>
        <GetEvent>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{R;R.?;P;P.?}.{RV.?}.{}</Annotation>
        </GetEvent>
        <GetProperties>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{Many{System.Reflection.PropertyInfo}}.{R;R.?}.{RV.?;RO.?}.{[RV, RO, ?]}</Annotation>
        </GetProperties>
        <GetGenericTypeDefinition>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{R;R.?}.{RV.?}.{}</Annotation>
        </GetGenericTypeDefinition>
        <GetGenericArguments>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{Many{System.Type}}.{R;R.?}.{RV.?;RO.?}.{[RV, RO, ?]}</Annotation>
        </GetGenericArguments>
        <MakeGenericType>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{P;P.?;P.?.?}.{RV.?}.{}</Annotation>
        </MakeGenericType>
      </Methods>
    </Type>
    <GC>
      <Methods>
        <AnnotationType>Predefined</AnnotationType>
        <Annotation>Nothing</Annotation>
      </Methods>
    </GC>
    <IComparable>
      <Methods>
        <CompareTo>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R;R.?;R.*.?;P;P.?;P.*.?}.{}.{}</Annotation>
        </CompareTo>
      </Methods>
    </IComparable>
    <Activator>
      <Methods>
        <CreateInstance>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{Many}.{P;P.?}.{RV.?;RO.?}.{[RV;RO, RO, ?], [RO, RV, ?]}</Annotation>
        </CreateInstance>
      </Methods>
    </Activator>
    <Nullable>
      <Methods>
        <GetUnderlyingType>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{P;P.?}.{RV.?}.{}</Annotation>
        </GetUnderlyingType>
      </Methods>
    </Nullable>
  </System>
  <System.IO>
    <DirectoryInfo>
      <Methods>
        <ctor>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{P}.{RV.?}.{}</Annotation>
        </ctor>
      </Methods>
    </DirectoryInfo>
    <TextWriter>
      <Methods>
        <WriteLine>
          <AnnotationType>Predefined</AnnotationType>
          <Annotation>BasicScalarSystemCall</Annotation>
        </WriteLine>
      </Methods>
    </TextWriter>
  </System.IO>
  <System.Reflection>
    <Assembly>
      <Methods>
        <GetExecutingAssembly>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{}.{RV.?}.{}</Annotation>
        </GetExecutingAssembly>
      </Methods>
    </Assembly>
    <PropertyInfo>
      <Methods>
        <GetValue>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>IsIn{P.?}.{}.{R;R.?;P.?}.{}.{}</Annotation>
        </GetValue>
      </Methods>
    </PropertyInfo>
    <EventInfo>
      <Methods>
        <AddEventHandler>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R;P}.{R.?}.{}</Annotation>
        </AddEventHandler>
      </Methods>
    </EventInfo>
	<ConstructorInfo>
      <Methods>
        <Invoke>
          <AnnotationType>Custom</AnnotationType>
          <!-- It returns the new object by reading the previous one -->
          <Annotation>IsIn{P[1]}.{}.{R;R.?;P[0]}.{}.{}</Annotation>
        </Invoke>
      </Methods>
    </ConstructorInfo>
  </System.Reflection>
  <System.Linq>
    <Enumerable>
      <Methods>
        <First>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>IsIn{R.*.OfType{Object};P.*}.{}.{R.?;R.*.?;P.?;P.*.?}.{}.{}</Annotation>
        </First>
        <Select>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{P}.{RV.?}.{[RV, P, ?]}</Annotation>
        </Select>
        
        <Count>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P.?}.{}.{}</Annotation>
        </Count>
		<Concat>
          <AnnotationType>Predefined</AnnotationType>
          <Annotation>ReadAll_IsIn_Many</Annotation>
        </Concat>
        <Any>
          <AnnotationType>Predefined</AnnotationType>
          <Annotation>ReadAll_IsIn_Many</Annotation>
        </Any>
		<ToArray>
          <AnnotationType>Predefined</AnnotationType>
          <Annotation>ReadAll_IsIn_Many</Annotation>
        </ToArray>
      </Methods>
    </Enumerable>
	<ImmutableArrayExtensions>
      <Methods>
        <Single>
          <AnnotationType>Predefined</AnnotationType>
          <Annotation>ReadAll_IsIn_Many</Annotation>
        </Single>
        <Select>
          <AnnotationType>Predefined</AnnotationType>
          <Annotation>ReadAll_IsIn_Many</Annotation>
        </Select>
		<Where>
          <AnnotationType>Predefined</AnnotationType>
          <Annotation>ReadAll_IsIn_Many</Annotation>
        </Where>
      </Methods>
    </ImmutableArrayExtensions>
  </System.Linq>
  <System.Xml.Linq>
	<XNode>
		<Methods>
			<ToString>
				<AnnotationType>Predefined</AnnotationType>
				<Annotation>ReadAll</Annotation>
			</ToString>
		</Methods>
	</XNode>
	<XElement>
		<Methods>
			<DescendantsAndSelf>
				<AnnotationType>Predefined</AnnotationType>
				<Annotation>ReadAll_IsIn_Many</Annotation>
			</DescendantsAndSelf>
			<Attributes>
				<AnnotationType>Predefined</AnnotationType>
				<Annotation>ReadAll_IsIn_Many</Annotation>
			</Attributes>
		</Methods>
	</XElement>
  </System.Xml.Linq>
  <System.Collections>
    <ArrayList>
      <Methods>
        <Add>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R;R.?.?;P}.{R.?;R.?.?}.{[R.?, P, ?]}</Annotation>
        </Add>
        <!--<Count>
          <HavocType>ReadOnly</HavocType>
          <CallbackHavocType>ReadOnly</CallbackHavocType>
        </Count>
        <GetEnumerator>
          <HavocType>ReadOnlyPersistentReturn</HavocType>
          <CallbackHavocType>WriteThisReadParameters</CallbackHavocType>
        </GetEnumerator>
        <MoveNext>
          <HavocType>WriteThisReadParameters</HavocType>
          <CallbackHavocType>WriteThisReadParameters</CallbackHavocType>
        </MoveNext>-->
        <ctor>
          <!--<HavocType>WriteThisReadParameters</HavocType>-->
          <AnnotationType>Custom</AnnotationType>
          <!-- Podría ser más preciso con el tipo en Many y con el/los fields puntuales que se conecten -->
          <Annotation>Fresh.{Many}.{P}.{RV.?;RO.?}.{[RV, RO, ?]}</Annotation>
        </ctor>
        <!--<Contains>
          <HavocType>ReadOnly</HavocType>
          <CallbackHavocType>ReadOnly</CallbackHavocType>
        </Contains>-->
      </Methods>
    </ArrayList>
  </System.Collections>
  <System.Collections.Generic>
    <List>
      <Methods>
        <!--<Count>
          <HavocType>ReadOnly</HavocType>
          <CallbackHavocType>ReadOnly</CallbackHavocType>
        </Count>
        <GetEnumerator>
          <HavocType>ReadOnlyPersistentReturn</HavocType>
          <CallbackHavocType>WriteThisReadParameters</CallbackHavocType>
        </GetEnumerator>
        <MoveNext>
          <HavocType>WriteThisReadParameters</HavocType>
          <CallbackHavocType>WriteThisReadParameters</CallbackHavocType>
        </MoveNext>-->
        <Add>
          <AnnotationType>Custom</AnnotationType>
          <!--<Annotation>Null.{}.{R;R.?.?;P}.{R.?;R.?.?}.{[R.?, P, ?]}</Annotation>-->
          <Annotation>Null.{}.{R;R.?;R.*.UntilType{System.Array}.OfType{System.Array}.?;P}.{R.?;R.*.UntilType{System.Array}.OfType{System.Array}.?}.{[R.*.UntilType{System.Array}.OfType{System.Array}, P, ?]}</Annotation>
        </Add>
        <ctor>
          <!--<HavocType>WriteThisReadParameters</HavocType>-->
          <AnnotationType>Custom</AnnotationType>
          <!-- Podría ser más preciso con el tipo en Many y con el/los fields puntuales que se conecten -->
          <Annotation>Fresh.{Single{System.Array}}.{P}.{RV.?;RO.?}.{[RV, RO, ?]}</Annotation>
        </ctor>
        <!--<Sort>
          <HavocType>WriteThisReadParameters</HavocType>
        </Sort>-->
        <ToArray>
          <AnnotationType>Custom</AnnotationType>
          <!-- Podría ser más preciso con el tipo en Many y con el/los fields puntuales que se conecten -->
          <Annotation>Fresh.{}.{R;R.?;R.*.UntilType{System.Array}.OfType{System.Array}.?}.{RV.?}.{[RV, R.*.UntilType{@RV}.OfType{@RV}, ?]}</Annotation>
        </ToArray>
        <get_Item>
          <AnnotationType>Custom</AnnotationType>
          <!--<Annotation>IsIn{R.?.?.OfType{A}}.{}.{R.?;R.?.?;P}.{}.{}</Annotation>-->
          <Annotation>IsIn{R.*.UntilType{@RV}.OfType{@RV}}.{}.{R;R.?;R.?.?;P}.{}.{}</Annotation>
          <!--<Annotation>IsIn{R.*.UntilType{*T}.OfType{*T}}.{}.{R.?;R.?.?;P}.{}.{}</Annotation>-->
        </get_Item>
        <set_Item>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R;R.?;R.?.?;P}.{R.?.?}.{[R.?, P[1], ?]}</Annotation>
        </set_Item>
        <Sort>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R;R.?;R.*.UntilType{System.Array}.OfType{System.Array}.?;P;P.?}.{R.?;R.*.UntilType{System.Array}.OfType{System.Array}.?}.{}</Annotation>
        </Sort>
      </Methods>
    </List>
    <IList>
      <Methods>
        <GetEnumerator>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{R.?}.{RV.?}.{[RV, R, list]}</Annotation>
        </GetEnumerator>
        <MoveNext>
          <!-- TODO: CHECK -->
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R.?;R.?.?}.{R.?}.{[R, R.*, Current]}</Annotation>
        </MoveNext>
        <Add>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R;R.?.?;P}.{R.?;R.?.?}.{[R.?, P, ?]}</Annotation>
        </Add>
        <get_Item>
          <AnnotationType>Custom</AnnotationType>
          <!--<Annotation>IsIn{R.?.?.OfType{A}}.{}.{R.?;R.?.?;P}.{}.{}</Annotation>-->
          <Annotation>IsIn{R.*.UntilType{@RV}.OfType{@RV}}.{}.{R;R.?;R.?.?;P}.{}.{}</Annotation>
          <!--<Annotation>IsIn{R.*.UntilType{*T}.OfType{*T}}.{}.{R.?;R.?.?;P}.{}.{}</Annotation>-->
        </get_Item>
        <set_Item>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R;R.?;R.?.?;P}.{R.?.?}.{[R.?, P[1], ?]}</Annotation>
        </set_Item>
      </Methods>
    </IList>
    <Dictionary>
      <Methods>
        <ctor>
          <AnnotationType>Custom</AnnotationType>
          <!-- Podría ser más preciso con el tipo en Many y con el/los fields puntuales que se conecten (TODO) -->
          <Annotation>Fresh.{Many{|DictInternal}}.{P}.{RV.?;RO.?}.{[RV;RO, RO, ?], [RO, P, ?]}</Annotation>
        </ctor>
        <ContainsKey>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R;R.?;R.?.?.OfKind{DictInternal}.?;P}.{}.{}</Annotation>
        </ContainsKey>
        <Add>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R;R.?;R.?.?.OfKind{DictInternal}.?;P}.{R.?.?.OfKind{DictInternal}.?}.{[R.?.?.OfKind{DictInternal}, P, ?]}</Annotation>
        </Add>
      </Methods>
    </Dictionary>
    <ICollection>
      <Methods>
        <Add>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{R;R.?;R.?.OfType{System.Array}.?;P}.{R.?;R.?.OfType{System.Array}.?}.{[R.?.OfType{System.Array}, P, ?]}</Annotation>
        </Add>
        <ctor></ctor>
      </Methods>
    </ICollection>
    <HashSet>
      <Methods>
        <ctor>
          <AnnotationType>Custom</AnnotationType>
          <!-- Podría ser más preciso con el tipo en Many y con el/los fields puntuales que se conecten (TODO) -->
          <Annotation>Fresh.{Many{|HashSet}}.{P}.{RV.?;RO.?}.{[RV, RO, ?], [RO, P, ?]}</Annotation>
        </ctor>
      </Methods>
    </HashSet>
    <IEnumerable>
      <Methods>
        <ctor>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{P}.{RV.?}.{[RV, P, ?]}</Annotation>
        </ctor>
        <Add>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P}.{R.?}.{[R, P, ?]}</Annotation>
        </Add>
      </Methods>
    </IEnumerable>
  </System.Collections.Generic>
  <EqualityComparer>
	  <Methods>
        <Equals>
          <AnnotationType>Predefined</AnnotationType>
          <Annotation>ReadAll</Annotation>
        </Equals>	
      </Methods>
	</EqualityComparer>
  <System.ComponentModel>
    <ListChangedEventArgs>
      <Methods>
        <ctor>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{P;P.?}.{RV.?}.{}</Annotation>
        </ctor>
      </Methods>
    </ListChangedEventArgs>
    <TypeDescriptor>
      <Methods>
        <GetProperties>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{Many{|PropertiesInfo}}.{P;P.?}.{RV.?;RO.?}.{[RV;RO, RO, ?]}</Annotation>
        </GetProperties>
      </Methods>
    </TypeDescriptor>
  </System.ComponentModel>
  <System.Diagnostics>
    <Process>
      <Methods>
        <GetCurrentProcess>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{Many}.{}.{RV.?;RO.?}.{[RV;RO, RO, ?]}</Annotation>
        </GetCurrentProcess>
      </Methods>
    </Process>
    <Debug>
      <Methods>
        <Assert>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P}.{}.{}</Annotation>
        </Assert>
      </Methods>
    </Debug>
  </System.Diagnostics>
  <System.Diagnostics.Contracts>
    <Contract>
      <Methods>
        <EndContractBlock>
          <AnnotationType>Predefined</AnnotationType>
          <Annotation>Nothing</Annotation>
        </EndContractBlock>
      </Methods>
    </Contract>
  </System.Diagnostics.Contracts>
  <log4net>
    <LogManager>
      <Methods>
        <GetLogger>
          <AnnotationType>Custom</AnnotationType>
          <!--<Annotation>Fresh.{Many}.{P;P.?;P.*.?}.{RV.?;RO.?}.{[RV;RO, RO, ?]}</Annotation> HACKKK -->
          <Annotation>Fresh.{Many{|L}}.{P;P.?;P.*.?}.{RV.?;RO.?}.{[RV;RO, RO, ?]}</Annotation>
        </GetLogger>
      </Methods>
    </LogManager>
    <ILog>
      <Methods>
        <Info>
          <AnnotationType>Predefined</AnnotationType>
          <Annotation>BasicScalarSystemCall</Annotation>
        </Info>
      </Methods>
    </ILog>
  </log4net>
  <System.Windows.Forms>
    <Application>
      <Methods>
        <EnableVisualStyles>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P}.{}.{}</Annotation>
        </EnableVisualStyles>
        <SetCompatibleTextRenderingDefault>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P}.{}.{}</Annotation>
        </SetCompatibleTextRenderingDefault>
      </Methods>
    </Application>
  </System.Windows.Forms>
  <System.Resources>
    <ResourceManager>
      <Methods>
        <ctor>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{Many{|ResMan}}.{P;P.?}.{RV.?;RO.?}.{[RV;RO, RO, ?], [RO, RV, ?]}</Annotation>
        </ctor>
        <GetObject>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{R;R.?;R.?.?;P;P.?}.{RV.?}.{}</Annotation>
        </GetObject>
      </Methods>
    </ResourceManager>
  </System.Resources>
  <System.Drawing>
    <Point>
      <Methods>
        <ctor>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{P}.{RV.?}.{}</Annotation>
        </ctor>
      </Methods>
    </Point>
    <Size>
      <Methods>
        <ctor>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{P}.{RV.?}.{}</Annotation>
        </ctor>
      </Methods>
    </Size>
    <Font>
      <Methods>
        <ctor>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Fresh.{}.{P}.{RV.?}.{}</Annotation>
        </ctor>
      </Methods>
    </Font>
  </System.Drawing>
  <PSTests>
    <CustomAssert>
      <Methods>
        <Null>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P}.{}.{}</Annotation>
        </Null>
		<NotNull>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P}.{}.{}</Annotation>
        </NotNull>
		<Equal>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P}.{}.{}</Annotation>
        </Equal>
		<NotEqual>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P}.{}.{}</Annotation>
        </NotEqual>
		<Empty>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P;P.*}.{}.{}</Annotation>
        </Empty>
		<NotEmpty>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P;P.*}.{}.{}</Annotation>
        </NotEmpty>
		<Contains>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P;P.*}.{}.{}</Annotation>
        </Contains>
		<Same>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P;P.*}.{}.{}</Annotation>
        </Same>
		<NotSame>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P;P.*}.{}.{}</Annotation>
        </NotSame>
		<IsType>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P;P.*}.{}.{}</Annotation>
        </IsType>
		<IsAssignableFrom>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P;P.*}.{}.{}</Annotation>
        </IsAssignableFrom>
		<Throws>
          <AnnotationType>Custom</AnnotationType>
          <Annotation>Null.{}.{P;P.*}.{}.{}</Annotation>
        </Throws>
      </Methods>
    </CustomAssert>
  </PSTests>
</Summaries>